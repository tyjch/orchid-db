{"metadata": {"dbt_schema_version": "https://schemas.getdbt.com/dbt/run-results/v6.json", "dbt_version": "1.9.8", "generated_at": "2025-06-13T21:32:04.759760Z", "invocation_id": "6f372f3f-3e2e-4f4d-a060-2d03e88f9ce8", "env": {}}, "results": [{"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-13T21:31:30.087137Z", "completed_at": "2025-06-13T21:31:30.103136Z"}, {"name": "execute", "started_at": "2025-06-13T21:31:30.183137Z", "completed_at": "2025-06-13T21:31:33.786923Z"}], "thread_id": "Thread-1 (worker)", "execution_time": 3.703310012817383, "adapter_response": {"_message": "SELECT 1898926", "code": "SELECT", "rows_affected": 1898926}, "message": "SELECT 1898926", "failures": null, "unique_id": "model.orchid_db.taxonomy_gbif", "compiled": true, "compiled_code": "\n\nwith source_data as (\n    select * from \"orchid-db\".\"raw\".\"gbif_taxonomy\"\n),\n\nfinal as (\n    select\n        -- IDs (prefix with gbif-)\n        concat('gbif-', \"taxonID\") as id,\n        case when \"parentNameUsageID\" is not null \n             then concat('gbif-', \"parentNameUsageID\") \n             else null end as parent_id,\n        case when \"acceptedNameUsageID\" is not null \n             then concat('gbif-', \"acceptedNameUsageID\") \n             else null end as accepted_id,\n        case when \"originalNameUsageID\" is not null \n             then concat('gbif-', \"originalNameUsageID\") \n             else null end as original_id,\n        \n        -- Name with WFO-style formatting for infraspecifics\n        case \n            when \"taxonRank\" = 'subspecies' and \"infraspecificEpithet\" is not null \n                then concat(\"genericName\", ' ', \"specificEpithet\", ' subsp. ', \"infraspecificEpithet\")\n            when \"taxonRank\" = 'variety' and \"infraspecificEpithet\" is not null \n                then concat(\"genericName\", ' ', \"specificEpithet\", ' var. ', \"infraspecificEpithet\")\n            when \"taxonRank\" = 'form' and \"infraspecificEpithet\" is not null \n                then concat(\"genericName\", ' ', \"specificEpithet\", ' f. ', \"infraspecificEpithet\")\n            else coalesce(\"canonicalName\", \"scientificName\")\n        end as name,\n        \n        -- Name components\n        \"specificEpithet\" as specific_name,\n        \"infraspecificEpithet\" as infra_name,\n        \n        -- Taxonomic hierarchy (GBIF has broad hierarchy)\n        kingdom,\n        phylum,\n        class,\n        \"order\",\n        family,\n        null as subfamily,\n        null as tribe,\n        null as subtribe,\n        genus,\n        null as subgenus,\n        \"genericName\" as generic_name,\n        \n        -- Classification and status\n        \"taxonRank\" as rank,\n        case \n            when upper(\"taxonomicStatus\") = 'ACCEPTED' then 'accepted'\n            when upper(\"taxonomicStatus\") = 'SYNONYM' then 'synonym'\n            when upper(\"taxonomicStatus\") = 'INVALID' then 'invalid'\n            when upper(\"taxonomicStatus\") = 'UNRESOLVED' then 'unresolved'\n            when upper(\"taxonomicStatus\") = 'MISAPPLIED' then 'misapplied'\n            else lower(\"taxonomicStatus\")\n        end as taxonomic_status,\n        case \n            when upper(\"nomenclaturalStatus\") = 'LEGITIMATE' then 'legitimate'\n            when upper(\"nomenclaturalStatus\") = 'ILLEGITIMATE' then 'illegitimate'\n            when upper(\"nomenclaturalStatus\") = 'SUPERFLUOUS' then 'superfluous'\n            when upper(\"nomenclaturalStatus\") = 'REJECTED' then 'rejected'\n            when upper(\"nomenclaturalStatus\") = 'INVALID' then 'invalid'\n            else lower(\"nomenclaturalStatus\")\n        end as nomenclatural_status,\n        \n        -- External identifiers (not available in GBIF)\n        null as ipni_id,\n        null as tpl_id,\n        \n        -- Metadata\n        'GBIF' as data_source,\n        current_timestamp as dbt_loaded_at\n        \n    from source_data\n    where \n        -- Basic data quality filters\n        \"taxonID\" is not null\n        and coalesce(\"canonicalName\", \"scientificName\") is not null\n        and trim(coalesce(\"canonicalName\", \"scientificName\")) != ''\n        and kingdom = 'Plantae'  -- Only plants\n)\n\nselect * from final", "relation_name": "\"orchid-db\".\"public_taxonomy\".\"taxonomy_gbif\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-13T21:31:30.094136Z", "completed_at": "2025-06-13T21:31:30.102136Z"}, {"name": "execute", "started_at": "2025-06-13T21:31:30.104136Z", "completed_at": "2025-06-13T21:31:35.957552Z"}], "thread_id": "Thread-2 (worker)", "execution_time": 5.873414993286133, "adapter_response": {"_message": "SELECT 1980747", "code": "SELECT", "rows_affected": 1980747}, "message": "SELECT 1980747", "failures": null, "unique_id": "model.orchid_db.taxonomy_wfo", "compiled": true, "compiled_code": "\n\nwith source_data as (\n    select * from \"orchid-db\".\"raw\".\"wfo_taxonomy\"\n),\n\nfinal as (\n    select\n        taxonid as id,\n        parentnameusageid as parent_id,\n        acceptednameusageid as accepted_id,\n        originalnameusageid as original_id,\n        scientificname as name,\n        specificepithet as specific_name,\n        infraspecificepithet as infra_name,\n        null as kingdom,\n        null as phylum,\n        null as class,\n        null as \"order\",\n        family,\n        subfamily,\n        tribe,\n        subtribe,\n        genus,\n        subgenus,\n        null as generic_name,\n        taxonrank as rank,\n        case \n            when upper(taxonomicstatus) = 'ACCEPTED' then 'accepted'\n            when upper(taxonomicstatus) = 'SYNONYM' then 'synonym'\n            when upper(taxonomicstatus) = 'INVALID' then 'invalid'\n            when upper(taxonomicstatus) = 'UNRESOLVED' then 'unresolved'\n            when upper(taxonomicstatus) = 'MISAPPLIED' then 'misapplied'\n            else lower(taxonomicstatus)\n        end as taxonomic_status,\n        case \n            when upper(nomenclaturalstatus) = 'LEGITIMATE' then 'legitimate'\n            when upper(nomenclaturalstatus) = 'ILLEGITIMATE' then 'illegitimate'\n            when upper(nomenclaturalstatus) = 'SUPERFLUOUS' then 'superfluous'\n            when upper(nomenclaturalstatus) = 'REJECTED' then 'rejected'\n            when upper(nomenclaturalstatus) = 'INVALID' then 'invalid'\n            else lower(nomenclaturalstatus)\n        end as nomenclatural_status,\n        -- External identifiers\n        case \n            when scientificnameid like 'urn:lsid:ipni.org:names:%'\n            then split_part(scientificnameid, ':', -1)\n            else scientificnameid\n        end as ipni_id,\n        tplid as tpl_id,\n        'WFO' as data_source,\n        current_timestamp as dbt_loaded_at\n    from source_data\n    where taxonid is not null\n        and scientificname is not null\n        and trim(scientificname) != ''\n)\n\nselect * from final", "relation_name": "\"orchid-db\".\"public\".\"taxonomy_wfo\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-13T21:31:30.097134Z", "completed_at": "2025-06-13T21:31:30.103136Z"}, {"name": "execute", "started_at": "2025-06-13T21:31:30.180135Z", "completed_at": "2025-06-13T21:31:48.109405Z"}], "thread_id": "Thread-3 (worker)", "execution_time": 18.02526569366455, "adapter_response": {"_message": "SELECT 91950", "code": "SELECT", "rows_affected": 91950}, "message": "SELECT 91950", "failures": null, "unique_id": "model.orchid_db.taxonomy_wiz", "compiled": true, "compiled_code": "\n\nwith species_names_data as (\n    select * from \"orchid-db\".\"raw\".\"wiz_species_names\"\n),\n\ngenera_data as (\n    select * from \"orchid-db\".\"raw\".\"wiz_genera\"\n),\n\nclassifications_data as (\n    select * from \"orchid-db\".\"raw\".\"wiz_classifications\"\n),\n\ninfras_data as (\n    select * from \"orchid-db\".\"raw\".\"wiz_infras\"\n),\n\n-- Main species and varieties from SpeciesNames (primary source)\nmain_taxa as (\n    select\n        sn.\"SpName\"::integer as spname_id,\n        sn.\"Species\"::integer as species_id,\n        sn.\"Genus\"::text as genus_abbrev,\n        sn.\"Name\"::text as full_name,  -- Could be species, variety, etc.\n        \n        -- Determine rank from name structure\n        case \n            when sn.\"Name\" like '% var. %' or sn.\"Name\" like '% v. %' or sn.\"Name\" like '% nv. %' or sn.\"Name\" like '% Br. fol. %' then 'variety'\n            when sn.\"Name\" like '% ssp. %' or sn.\"Name\" like '% subsp. %' then 'subspecies'\n            when sn.\"Name\" like '% f. %' or sn.\"Name\" like '% forma %' or sn.\"Name\" like '% nm. %' or sn.\"Name\" like '% monstr. %' then 'form'\n            when sn.\"Name\" like '% h.v. %' then 'variety'  -- horticultural variety\n            when sn.\"Name\" like '% h.f. %' then 'form'     -- horticultural form\n            when sn.\"Name\" like '% sp. %' then 'species'   -- unidentified species\n            else 'species'\n        end as determined_rank,\n        \n        -- Extract species epithet and infraspecific parts\n        case \n            when sn.\"Name\" like '% var. %' then split_part(sn.\"Name\", ' var. ', 1)\n            when sn.\"Name\" like '% ssp. %' then split_part(sn.\"Name\", ' ssp. ', 1)  \n            when sn.\"Name\" like '% subsp. %' then split_part(sn.\"Name\", ' subsp. ', 1)\n            when sn.\"Name\" like '% f. %' then split_part(sn.\"Name\", ' f. ', 1)\n            when sn.\"Name\" like '% h.v. %' then split_part(sn.\"Name\", ' h.v. ', 1)\n            when sn.\"Name\" like '% h.f. %' then split_part(sn.\"Name\", ' h.f. ', 1)\n            else sn.\"Name\"\n        end as species_epithet,\n        \n        case \n            when sn.\"Name\" like '% var. %' then split_part(sn.\"Name\", ' var. ', 2)\n            when sn.\"Name\" like '% ssp. %' then split_part(sn.\"Name\", ' ssp. ', 2)\n            when sn.\"Name\" like '% subsp. %' then split_part(sn.\"Name\", ' subsp. ', 2)  \n            when sn.\"Name\" like '% f. %' then split_part(sn.\"Name\", ' f. ', 2)\n            when sn.\"Name\" like '% h.v. %' then split_part(sn.\"Name\", ' h.v. ', 2)\n            when sn.\"Name\" like '% h.f. %' then split_part(sn.\"Name\", ' h.f. ', 2)\n            else null\n        end as infraspecific_epithet\n        \n    from species_names_data sn\n    where sn.\"Name\" is not null\n        and trim(sn.\"Name\") != ''\n        and sn.\"Genus\" is not null\n        and trim(sn.\"Genus\") != ''\n),\n\n-- Add infraspecific taxa from Infras table\ninfra_taxa as (\n    select\n        null::integer as spname_id,  -- No SpName ID for infras\n        inf.\"Species\"::integer as species_id,\n        inf.\"Genus\"::text as genus_abbrev,\n        inf.\"Name\"::text as full_name,\n        \n        -- Determine rank from name structure\n        case \n            when inf.\"Name\" like '% var. %' then 'variety'\n            when inf.\"Name\" like '% ssp. %' or inf.\"Name\" like '% subsp. %' then 'subspecies'\n            when inf.\"Name\" like '% f. %' or inf.\"Name\" like '% forma %' then 'form'\n            when inf.\"Name\" like '% nothovar. %' then 'variety'  -- nothovariety\n            else 'subspecies'  -- Default for infras\n        end as determined_rank,\n        \n        -- Extract species epithet and infraspecific parts  \n        case \n            when inf.\"Name\" like '% var. %' then split_part(inf.\"Name\", ' var. ', 1)\n            when inf.\"Name\" like '% ssp. %' then split_part(inf.\"Name\", ' ssp. ', 1)\n            when inf.\"Name\" like '% subsp. %' then split_part(inf.\"Name\", ' subsp. ', 1)\n            when inf.\"Name\" like '% nothovar. %' then split_part(inf.\"Name\", ' nothovar. ', 1)\n            when inf.\"Name\" like '% f. %' then split_part(inf.\"Name\", ' f. ', 1)\n            else inf.\"Name\"\n        end as species_epithet,\n        \n        case \n            when inf.\"Name\" like '% var. %' then split_part(inf.\"Name\", ' var. ', 2)\n            when inf.\"Name\" like '% ssp. %' then split_part(inf.\"Name\", ' ssp. ', 2)\n            when inf.\"Name\" like '% subsp. %' then split_part(inf.\"Name\", ' subsp. ', 2)\n            when inf.\"Name\" like '% nothovar. %' then split_part(inf.\"Name\", ' nothovar. ', 2)\n            when inf.\"Name\" like '% f. %' then split_part(inf.\"Name\", ' f. ', 2)\n            else null\n        end as infraspecific_epithet\n        \n    from infras_data inf\n    where inf.\"Name\" is not null\n        and trim(inf.\"Name\") != ''\n        and inf.\"Genus\" is not null\n        and trim(inf.\"Genus\") != ''\n),\n\n-- Union all taxa\nall_taxa as (\n    select * from main_taxa\n    union all\n    select * from infra_taxa\n),\n\nfinal as (\n    select\n        -- IDs (use SpName if available, otherwise generate from Species + sequence)\n        case \n            when t.spname_id is not null then concat('wiz-', t.spname_id)\n            else concat('wiz-infra-', t.species_id, '-', row_number() over (partition by t.species_id, t.genus_abbrev order by t.full_name))\n        end as id,\n        \n        -- Parent relationships (link infraspecifics to their species)\n        case \n            when t.determined_rank in ('subspecies', 'variety', 'form') \n            then (\n                select concat('wiz-', mt.spname_id)\n                from main_taxa mt \n                where mt.species_id = t.species_id \n                    and mt.genus_abbrev = t.genus_abbrev\n                    and mt.species_epithet = t.species_epithet\n                    and mt.determined_rank = 'species'\n                limit 1\n            )\n            else null \n        end as parent_id,\n        \n        null as accepted_id,  -- Could link synonyms to accepted names\n        null as original_id,\n        \n       \n        case \n            when g.\"Name\" is not null then \n                case \n                    when t.full_name like '% h.v. %' then \n                        concat(g.\"Name\", ' ', replace(t.full_name, ' h.v. ', ' var. '))\n                    when t.full_name like '% h.f. %' then \n                        concat(g.\"Name\", ' ', replace(t.full_name, ' h.f. ', ' f. '))\n                    when t.full_name like '% v. %' then \n                        concat(g.\"Name\", ' ', replace(t.full_name, ' v. ', ' var. '))\n                    when t.full_name like '% nm. %' then \n                        concat(g.\"Name\", ' ', replace(t.full_name, ' nm. ', ' f. '))\n                    when t.full_name like '% nv. %' then \n                        concat(g.\"Name\", ' ', replace(t.full_name, ' nv. ', ' var. '))\n                    when t.full_name like '% monstr. %' then \n                        concat(g.\"Name\", ' ', replace(t.full_name, ' monstr. ', ' f. '))\n                    when t.full_name like '% subsp. %' then \n                        concat(g.\"Name\", ' ', replace(t.full_name, ' subsp. ', ' ssp. '))\n                    when t.full_name like '% sp. %' then \n                        concat(g.\"Name\", ' ', replace(t.full_name, ' sp. ', ' '))\n                    when t.full_name like '% Br. fol. %' then \n                        concat(g.\"Name\", ' ', replace(t.full_name, ' Br. fol. ', ' var. '))\n                    else \n                        concat(g.\"Name\", ' ', t.full_name)\n                end\n            else \n                case \n                    when t.full_name like '% h.v. %' then \n                        concat(t.genus_abbrev, ' ', replace(t.full_name, ' h.v. ', ' var. '))\n                    when t.full_name like '% h.f. %' then \n                        concat(t.genus_abbrev, ' ', replace(t.full_name, ' h.f. ', ' f. '))\n                    when t.full_name like '% v. %' then \n                        concat(t.genus_abbrev, ' ', replace(t.full_name, ' v. ', ' var. '))\n                    when t.full_name like '% nm. %' then \n                        concat(t.genus_abbrev, ' ', replace(t.full_name, ' nm. ', ' f. '))\n                    when t.full_name like '% nv. %' then \n                        concat(t.genus_abbrev, ' ', replace(t.full_name, ' nv. ', ' var. '))\n                    when t.full_name like '% monstr. %' then \n                        concat(t.genus_abbrev, ' ', replace(t.full_name, ' monstr. ', ' f. '))\n                    when t.full_name like '% subsp. %' then \n                        concat(t.genus_abbrev, ' ', replace(t.full_name, ' subsp. ', ' ssp. '))\n                    when t.full_name like '% sp. %' then \n                        concat(t.genus_abbrev, ' ', replace(t.full_name, ' sp. ', ' '))\n                    when t.full_name like '% Br. fol. %' then \n                        concat(t.genus_abbrev, ' ', replace(t.full_name, ' Br. fol. ', ' var. '))\n                    else \n                        concat(t.genus_abbrev, ' ', t.full_name)\n                end\n        end as name,\n        \n        \n        t.species_epithet as specific_name,\n        t.infraspecific_epithet as infra_name,\n        \n        \n        'Plantae' as kingdom,\n        'Tracheophyta' as phylum,\n        'Liliopsida' as class,\n        'Asparagales' as \"order\",\n        'Orchidaceae' as family,\n        g.\"Subfamily\" as subfamily,\n        g.\"Tribe\" as tribe,\n        g.\"Subtribe\" as subtribe,\n        coalesce(g.\"Name\", t.genus_abbrev) as genus,\n        c.\"Subgenus\" as subgenus,\n        coalesce(g.\"Name\", t.genus_abbrev) as generic_name,\n        \n        -- Classification and status\n        t.determined_rank as rank,\n        'accepted' as taxonomic_status,\n        'valid' as nomenclatural_status,\n        \n        -- External identifiers\n        null as ipni_id,\n        null as tpl_id,\n        \n        -- Metadata\n        'OrchidWiz' as data_source,\n        \n        -- Additional OrchidWiz-specific fields\n        c.\"Section\" as section\n        \n    from all_taxa t\n    left join genera_data g on t.genus_abbrev = g.\"Genus\"\n    left join classifications_data c on t.species_id::text = c.\"Species\"::text\n)\n\nselect * from final\norder by name", "relation_name": "\"orchid-db\".\"public\".\"taxonomy_wiz\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-13T21:31:48.115434Z", "completed_at": "2025-06-13T21:31:48.119953Z"}, {"name": "execute", "started_at": "2025-06-13T21:31:48.119953Z", "completed_at": "2025-06-13T21:31:59.413224Z"}], "thread_id": "Thread-5 (worker)", "execution_time": 11.298822164535522, "adapter_response": {"_message": "SELECT 3971623", "code": "SELECT", "rows_affected": 3971623}, "message": "SELECT 3971623", "failures": null, "unique_id": "model.orchid_db.taxonomy_merged", "compiled": true, "compiled_code": "-- models/staging/taxonomy_merged.sql\n\n\nwith wfo_data as (\n    select * from \"orchid-db\".\"public\".\"taxonomy_wfo\"\n),\n\ngbif_data as (\n    select * from \"orchid-db\".\"public_taxonomy\".\"taxonomy_gbif\"\n),\n\norchidwiz_data as (\n    select * from \"orchid-db\".\"public\".\"taxonomy_wiz\"\n),\n\nunified as (\n    select\n        id,\n        parent_id,\n        accepted_id,\n        original_id,\n        name,\n        specific_name,\n        infra_name,\n        kingdom,\n        phylum,\n        class,\n        \"order\",\n        family,\n        subfamily,\n        tribe,\n        subtribe,\n        genus,\n        subgenus,\n        generic_name,\n        rank,\n        taxonomic_status,\n        nomenclatural_status,\n        ipni_id,\n        tpl_id,\n        data_source,\n        null as section  -- Add section column for consistency\n    from wfo_data\n    \n    union all\n    \n    select\n        id,\n        parent_id,\n        accepted_id,\n        original_id,\n        name,\n        specific_name,\n        infra_name,\n        kingdom,\n        phylum,\n        class,\n        \"order\",\n        family,\n        subfamily,\n        tribe,\n        subtribe,\n        genus,\n        subgenus,\n        generic_name,\n        rank,\n        taxonomic_status,\n        nomenclatural_status,\n        ipni_id,\n        tpl_id,\n        data_source,\n        null as section  -- Add section column for consistency\n    from gbif_data\n    \n    union all\n    \n    select\n        id,\n        parent_id,\n        accepted_id,\n        original_id,\n        name,\n        specific_name,\n        infra_name,\n        kingdom,\n        phylum,\n        class,\n        \"order\",\n        family,\n        subfamily,\n        tribe,\n        subtribe,\n        genus,\n        subgenus,\n        generic_name,\n        rank,\n        taxonomic_status,\n        nomenclatural_status,\n        ipni_id,\n        tpl_id,\n        data_source,\n        section\n    from orchidwiz_data\n),\n\nnormalized as (\n    select\n        id,\n        parent_id,\n        accepted_id,\n        original_id,\n        \n        -- Normalize botanical abbreviations and clean name\n        \n    REGEXP_REPLACE(\n        REGEXP_REPLACE(\n            REGEXP_REPLACE(\n                REGEXP_REPLACE(\n                    name,\n                    ' subsp\\. ', ' ssp. ', 'g'\n                ),\n                ' fo\\. ', ' f. ', 'g'\n            ),\n            ' sect\\. [A-Z][a-z]*', '', 'g'\n        ),\n        ' subg\\. [A-Z][a-z]*', '', 'g'\n    )\n as name,\n        \n        specific_name,\n        infra_name,\n        kingdom,\n        phylum,\n        class,\n        \"order\",\n        family,\n        subfamily,\n        tribe,\n        subtribe,\n        genus,\n        \n        -- Extract subgenus from name if not already populated\n        coalesce(\n            subgenus,\n            \n    CASE \n        WHEN name ~ ' subg\\. [A-Z][a-z]*'\n        THEN substring(name, ' subg\\. ([A-Z][a-z]*)')\n        ELSE NULL\n    END\n\n        ) as subgenus,\n        \n        generic_name,\n        rank,\n        taxonomic_status,\n        nomenclatural_status,\n        ipni_id,\n        tpl_id,\n        data_source,\n        \n        -- Extract section from name if not already populated\n        coalesce(\n            section,\n            \n    CASE \n        WHEN name ~ ' sect\\. [A-Z][a-z]*'\n        THEN substring(name, ' sect\\. ([A-Z][a-z]*)')\n        ELSE NULL\n    END\n\n        ) as section\n        \n    from unified\n)\n\nselect * from normalized\norder by name, data_source", "relation_name": "\"orchid-db\".\"public\".\"taxonomy_merged\"", "batch_results": null}, {"status": "success", "timing": [{"name": "compile", "started_at": "2025-06-13T21:31:59.418225Z", "completed_at": "2025-06-13T21:31:59.421224Z"}, {"name": "execute", "started_at": "2025-06-13T21:31:59.421224Z", "completed_at": "2025-06-13T21:32:04.721761Z"}], "thread_id": "Thread-7 (worker)", "execution_time": 5.305531740188599, "adapter_response": {"_message": "SELECT 635395", "code": "SELECT", "rows_affected": 635395}, "message": "SELECT 635395", "failures": null, "unique_id": "model.orchid_db.taxonomy_unified", "compiled": true, "compiled_code": "\n\nwith merged_data as (\n    select * from \"orchid-db\".\"public\".\"taxonomy_merged\"\n),\n\nunified as (\n    select \n        name,\n        MAX(kingdom) as kingdom,\n        MAX(phylum) as phylum,\n        MAX(class) as class,\n        MAX(\"order\") as \"order\",\n        MAX(family) as family,\n        MAX(subfamily) as subfamily,\n        MAX(tribe) as tribe,\n        MAX(subtribe) as subtribe,\n        MAX(genus) as genus,\n        MAX(subgenus) as subgenus,\n        MAX(section) as section,\n        rank\n    from merged_data\n    where taxonomic_status = 'accepted' \n        and rank != 'unranked'\n    group by name, rank\n)\n\nselect * from unified\norder by kingdom, phylum, class, \"order\", family, subfamily, tribe, subtribe, genus, subgenus, name", "relation_name": "\"orchid-db\".\"public\".\"taxonomy_unified\"", "batch_results": null}], "elapsed_time": 34.8512065410614, "args": {"partial_parse_file_diff": true, "quiet": false, "project_dir": "Z:\\Documents\\Programming\\orchid-db", "log_format_file": "debug", "invocation_command": "dbt run", "defer": false, "exclude": [], "which": "run", "static_parser": true, "log_format": "default", "state_modified_compare_more_unrendered_values": false, "use_colors_file": true, "version_check": true, "partial_parse": true, "send_anonymous_usage_stats": true, "log_level": "info", "favor_state": false, "strict_mode": false, "use_colors": true, "require_resource_names_without_spaces": false, "profiles_dir": "C:\\Users\\tyjch\\.dbt", "log_file_max_bytes": 10485760, "warn_error_options": {"include": [], "exclude": []}, "populate_cache": true, "require_nested_cumulative_type_params": false, "log_level_file": "debug", "macro_debugging": false, "printer_width": 80, "vars": {}, "write_json": true, "empty": false, "print": true, "skip_nodes_if_on_run_start_fails": false, "show_resource_report": false, "select": [], "source_freshness_run_project_hooks": false, "require_explicit_package_overrides_for_builtin_materializations": true, "log_path": "Z:\\Documents\\Programming\\orchid-db\\logs", "require_yaml_configuration_for_mf_time_spines": false, "state_modified_compare_vars": false, "introspect": true, "indirect_selection": "eager", "require_batched_execution_for_custom_microbatch_strategy": false, "cache_selected_only": false}}